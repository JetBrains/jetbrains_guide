JUnit has been around for a long time, and many applications will have a large number of JUnit tests written using JUnit 4. JUnit 5 was released in 2017, and provides a lot of features that weren't in the previous version. Let's look at how to migrate existing JUnit 4 tests to JUnit 5

A typical JUnit 4 test might contain sections like code to run once at the start of all the tests, code to run before each individual test, the tests themselves, some of which may be ignored, code to run to clean up after each test, and code to run once to clean up after all tests.

In this project we're currently using JUnit 4.13, but the guidelines we're going to go through apply to any version of JUnit 4.  We also have a dependency on Hamcrest so we can use those matchers in our JUnit tests.

The first thing we need to do in order to migrate to JUnit 5 is to add the JUnit 5 dependencies.  For most test suites all we'll need to do is add two new dependencies. If we search for JUnit dependencies, we'll see junit-jupiter dependencies, which are the JUnit 5 dependencies.  To start with let's add a dependency on the basic junit-jupiter-api. In this case, IntelliJ IDEA has identified that 5.7.0-(milestone one) is the latest dependency, I want to use a release version rather than a milestone, so I'm going to use code completion here to find out which other versions are available.  5.6.2 is the current release version.

Because we want to run existing JUnit 4 tests with JUnit 4, we need to add one more dependency.  We need to look for the JUnit vintage engine to run older tests.  Once again, IntelliJ IDEA is suggesting version 5.7.0-M1, let's expand the menu item using right arrow to see what other options are open to us.  Let's pick 5.6.2 so we’re using the same version as the api.

Since we've made changes to the maven pom, we'll need to ask IntelliJ IDEA to load these changes if we want the IDE to pick up the new dependencies. We can do this with the maven icon in the top right, or by pressing shift command and "i" on a mac or shift ctrl and o on windows and Linux.

We only need these dependencies to run tests, so we can add the test scope to them as well.  Now we should be able to safely remove the old JUnit 4 dependency, and the project will still compile.  We'll reload these maven changes too, to make sure IntelliJ IDEA removes the old dependency from the project.

Before we do anything else, let's check that everything still works the way we expect.  Let's rebuild the whole project with the new dependencies and check it all compiles and builds. If it all builds correctly, we can try running one of our tests to make sure that works the way we expect too. This project has opened the test results in the services window, but I'd like them to appear in their own run window, so let's remove the JUnit run configuration from the services window. Now we can see the results by opening the Run window, with Cmd 4 or Alt 4.

We can see our test ran correctly, and we know the project compiles too. So let's commit our changes before we go any further.  All we’ve changed is our Maven pom.xml, we added the new dependencies and removed the old JUnit 4 dependency.  If we check in our IntelliJ IDEA files, which I do in this project, we'll see that these have changed too, to reflect the new dependencies.  Let's commit all of this since we know everything works right now. We'll continue the migration in a series of small steps.

IntelliJ IDEA's inspections can be very helpful for migrating code of all kinds.  In particular there are a number of inspections for JUnit tests.  To help with the migration we can turn on the "JUnit 4 test can be JUnit 5" inspection, which automatically defaults to a warning.  Note that we can only turn this on if we're using at least Java 8 and have JUnit 5 dependencies set up, which is what we did in the last step.

With this inspection turned on, tests like this one, which were written in JUnit 4 but are currently running using the JUnit 5 vintage engine, are flagged to tell us we can migrate them.  If we press Alt and Enter, we're offered the option to migrate it to JUnit 5. The refactoring preview window will show the places where changes will be made, in this case a number of annotations will be changed to the new JUnit 5 annotations. The second section in this case is methods that will be changed because the assertions will be updated.  Let's do the refactoring and see what the new code looks like.

The main change is that instead of importing org.junit, which is the JUnit 4 package, the class will import org.junit.jupiter, which is the JUnit 5 package structure.  We'll see that the before and after annotation names have been changed to the new, more descriptive, ones: BeforeClass becomes BeforeAll, Before becomes BeforeEach.  The test annotation doesn't change, because the name is still the same.  Changing the import means this will now use the new Test annotation.  Assert statements now use methods on the Assertions class, instead of the old Assert.  The JUnit 4 @Ignore annotation has been replaced with the JUnit 5 @Disabled annotation.  Any tests that used Hamcrest matchers should still work as before.  JUnit 4.4 introduced the idea of assumptions, if these assumptions are met the test is run.  JUnit 5 provides an Assumptions class instead of Assume.  Like the Before Annotations, After is replaced with AfterEach, and AfterClass is replaced with AfterAll.

IntelliJ IDEA makes all of these changes automatically.  Like any IntelliJ IDEA refactoring, we can see the class still compiles after we've done the refactoring.  Let's run the test to make sure it still behaves the way we expect.  We see the beforeClass method is run once, each before and after method are run once per test, and the afterClass method is run once at the end, so the overall setup works as it did under JUnit 4.  We still have one test which is not run, our disabled test, and we have three passing tests, as we did before.

Now we've made this small change and seen that the code behaves the way we expect it to, we can check in these changes too.  If we're committing our IntelliJ IDEA files, we should see that the default inspection profile file has been changed to turn on our JUnit 5 converter.  And of course the test we migrated has also changed. Our changes are limited to the imports; the annotations; the assertions and assumptions. Let's commit these changes since everything is compiling and working as expected. Once these are committed we can move onto the next step.

Now we understand the individual steps to migrate a test, we can be a bit more ambitious with our migration. Let's try to automatically migrate all our tests.  We can use Find Action and type Migrate, to see migration options for our code.  IntelliJ IDEA offers the option to migrate our code from JUnit 4 to 5. This migration is similar to what we did with the individual test class, but for all test classes. We see the refactoring preview, and could decide not to refactor particular classes or methods if we wanted to.  Let's do the refactoring.

We want to check all our tests still work as before, so let's run them all.  It looks like everything passed, but there's quite a lot of information here. Let's hide all the tests that passed, since if they passed they don't need our attention.  Let's hide all the disabled tests, since we expected these three tests not to run.  Now there are no failed tests here and no indicator that anything went wrong. We can assume this migration worked as expected, and that now is a safe time to commit the changes.

We can see all the files that were changed by this migration. In the case of this project, it's all the test classes that exist.  We can go through each of the files to check the changes before we commit anything.  Shift Cmd and right square bracket, or ctrl and right arrow, will take us to the next file to compare so we can quickly check all the files.  Because these are mostly simple JUnit tests, most of the changes are a change to the imports to use the new JUnit Jupiter test annotation instead of the old JUnit test annotation.  Let's commit these changes and move on to the next step.

If the tests in the project are fairly straightforward ones, this automatic migration should take care of most of the tasks that need to happen.  However, not all cases can be managed automatically.

Migration from JUnit 4 to JUnit 5 could be a slow and steady process.


 At this point in our project, we have some tests fully migrated to JUnit 5, some partially migrated but using some JUnit 4 features, and potentially there may be some classic JUnit 4 (or even JUnit 3) tests running as they are. We're running them all using JUnit 5, so we can write new tests using the new JUnit 5 features but keep existing stable tests as they are, if we choose.

However we might want to remove the dependency on the vintage engine to prevent ourselves from accidentally writing tests in the old style.  If we remove this dependency, refresh the maven changes and rebuild the project, we will be able to see which classes require the vintage engine, and therefore which tests need more help migrating to JUnit 5.

One example of a change that we might do manually is to use the correct import for Hamcrest's assertThat.  We could do this by removing the reference to the JUnit Assert class, and getting IntelliJ IDEA to static import the Hamcrest MatcherAssert.assertThat. We can use optimise imports to remove the unnecessary JUnit 4 Assert import.

We may discover that some of our tests are even JUnit 3 style tests - these tests extend a TestCase instead of using annotations.  Let's put the vintage dependency back in to the pom so that the project compiles again, and let's not forget to reload the maven changes.  Let's go back to our JUnit 3 test case.  Pressing Alt and Enter on the class suggests that we can migrate this to JUnit 4, which seems like a good first step. Now the test uses annotations, and doesn't import anything from the old junit.framework package.  Now we can take the next step and migrate this test to JUnit 5.  We might also want to do optimise imports to remove any old imports that aren't needed.

To finish removing references to JUnit 4 classes, we could do a "find in Path" search for org.junit. This will show up everything, including our new Jupiter classes. We could try an expression to capture that the next character after the dot needs to be an upper case letter. This is a regular expression, and case sensitive. Now we can see all the remaining files that import a class from org.junit.  There are lots of ways we could fix this, one option is to simply remove the old import, use the new JUnit 5 Assertions class, and add a static import for the assertEquals method so it can be used by all tests in the class.

We can rerun the search to find the other places that need to be fixed up.  We can do the same thing here that we did in the other class, but there are other approaches we could take.

This specific problem, for example, can be fixed with an inspection. If we turn on "Obsolete assertions in Junit 5 tests" we can get IntelliJ IDEA to suggest using the new Junit 5 assertions. Now when we go back to the editor, we have a warning on the old assert statement, and we can get IntelliJ IDEA to automatically use the new Junit 5 Assertions instead.  IntelliJ IDEA does have inspections and automatic fixes to help migrate code from Junit 4 to Junit 5, but if there isn't a specific fix, we might take another approach,


like doing a find and replace, or a Structural search, which might be more appropriate if there are a lot of files to change but the changes are all the same. We could use live templates for common code, and we could configure our auto import settings to make sure the new JUnit imports are suggested over the old ones. The right solution will depend upon what sort of changes need to be made and how many files are affected.

Now we've removed all references to JUnit 4 classes and functionality, we can remove the vintage engine and use just the modern JUnit 5 test engine. Let's load the maven changes and rebuild the project, to see it all compiles.   We should check the tests still work and pass, which we can do by pressing ctrl twice to bring up the run anything window. If we type All we can see the all tests run configuration and run all our project's tests.  Everything passes, so we can be comfortable checking in these changes.

We have successfully migrated all the tests in this project to JUnit 5.  The first step was to migrate the project to run our JUnit 4 tests on the JUnit 5 platform. For many projects it may be enough to do this, and there may be no need to go all the way to removing the vintage engine.  The most important thing is to be able to write and run tests in the new JUnit 5 style. We'll cover the advantages of using JUnit 5 in another video.

Thanks for watching!